package com.hex.commonutil.utils;

/*
* Copyright 2021-2100 the original author or authors.
*
* Licensed under the Hexaware License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*      https://www.hexaware.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/


/**
* @author - auto generated by Amaze
* @created datetime - 2023/06/19 12:20:57
*/

import java.io.StringReader;
import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.math.BigInteger;
import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.TimeZone;
import java.util.concurrent.TimeUnit;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import org.apache.commons.lang.StringEscapeUtils;
import org.apache.commons.lang3.BooleanUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.xml.sax.InputSource;
import java.time.ZoneOffset;

import net.sf.saxon.om.Item;
import net.sf.saxon.value.DateTimeValue;
import net.sf.saxon.value.SequenceExtent;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.math.BigInteger;
import java.text.SimpleDateFormat;
import java.util.HashMap;
import java.util.Map;

import org.apache.commons.io.FileUtils;
import org.apache.commons.lang3.StringUtils;
import org.joda.time.DateTime;
import org.joda.time.DateTimeZone;
import org.slf4j.LoggerFactory;

/**
 * 
 * TibcoLibUtil - used to handle the data conversion and core tibco functionalities
 *
 */
public class TibcoLibUtil {

	private static Logger log = LogManager.getLogger(TibcoLibUtil.class);

	// Tibco String function
	/**
	 * append - appends a given string to the string buffer object
	 * @param stringBuffer
	 * @param stringToAppend
	 * @return Object
	 */
	public static Object append(Object stringBuffer, String stringToAppend) {
		return ((StringBuffer) stringBuffer).append(stringToAppend);
	}

	/**
	 * clearBuffer - clears the string buffer
	 * @param stringBuffer void
	 */
	public static void clearBuffer(Object stringBuffer) {
		stringBuffer = new StringBuffer();
	}

	/**
	 * compareTo - compares s1 and s2 
	 * @param s1
	 * @param s2
	 * @return int
	 */
	public static int compareTo(String s1, String s2) {
		return s1.compareTo(s2);
	}

	/**
	 * compareToIgnoreCase - compares s1 and s2 ignoring case
	 * @param s1
	 * @param s2
	 * @return int
	 */
	public static int compareToIgnoreCase(String s1, String s2) {
		return s1.compareToIgnoreCase(s2);
	}

	/**
	 * concat - concats s1 and s2
	 * @param s1
	 * @param s2
	 * @return String
	 */
	public static String concat(String s1, String s2) {
		return s1.concat(s2);
	}

	/**
	 * contains - checks if s1 string contains s2
	 * @param s1
	 * @param s2
	 * @return boolean
	 */
	public static boolean contains(String s1, String s2) {
		return s1.contains(s2);
	}

	/**
	 * convertBufferToString - casts StringBuffer object to String
	 * @param stringBuffer
	 * @return String
	 */
	public static String convertBufferToString(Object stringBuffer) {
		return ((StringBuffer) stringBuffer).toString();
	}

	/**
	 * convertByteArrayToString - converts byte array to string 
	 * @param bytesObject
	 * @param encoding
	 * @return String
	 */
	public static String convertByteArrayToString(byte[] bytesObject, String encoding) {
		try {
			return new String(bytesObject, encoding);
		} catch (UnsupportedEncodingException e) {
			log.error(e.getMessage());
		}

		return null;
	}

	/**
	 * endsWith - check if the s1 string ends with s2
	 * @param s1
	 * @param s2
	 * @return boolean
	 */
	public static boolean endsWith(String s1, String s2) {
		return s1.endsWith(s2);
	}

	/**
	 * equals - checks the string equality
	 * @param s1
	 * @param s2
	 * @return boolean
	 */
	public static boolean equals(String s1, String s2) {
		return s1.equals(s2);
	}

	/**
	 * format - used to format the string
	 * @param message
	 * @param arguments
	 * @return String
	 */
	public static String format(String message, Object... arguments) {
		return message.format(message, arguments);
	}

	/**
	 * getBytes - gets the byte code values for the string using the given character set
	 * @param s1
	 * @param charsetName
	 * @return Object
	 */
	public static Object getBytes(String s1, String charsetName) {
		try {
			return s1.getBytes(charsetName);
		} catch (UnsupportedEncodingException e) {
			log.error(e.getMessage());
		}
		return null;
	}

	/**
	 * hashCode - retrieves the hashcode of the given string
	 * @param s1
	 * @return int
	 */
	public static int hashCode(String s1) {
		return s1.hashCode();
	}

	/**
	 * indexOfString - from s1 gets the index of s2
	 * @param s1
	 * @param fromIndex
	 * @param s2
	 * @return int
	 */
	public static int indexOfString(String s1, int fromIndex, String s2) {
		return s1.indexOf(s2, fromIndex);
	}

	/**
	 * lastIndexOfString - from s1 gets the last index of s2
	 * @param s1
	 * @param fromIndex
	 * @param s2
	 * @return int
	 */
	public static int lastIndexOfString(String s1, int fromIndex, String s2) {
		return s1.lastIndexOf(s2, fromIndex);
	}

	/**
	 * left - gets the substring of the given number of characters
	 * @param s1
	 * @param length
	 * @return String
	 */
	public static String left(String s1, int length) {
		return s1.substring(length);
	}

	/**
	 * length - gets the string length
	 * @param s1
	 * @return int
	 */
	public static int length(String s1) {
		return s1.length();
	}

	/**
	 * matches - checks if the given string matches with the regex pattern
	 * @param s1
	 * @param regex
	 * @return boolean
	 */
	public static boolean matches(String s1, String regex) {
		return s1.matches(regex);
	}

	/**
	 * pad - right pads the padding character for the given length  
	 * @param str
	 * @param length
	 * @param padCharacter
	 * @return String
	 */
	public static String pad(String str, int length, String padCharacter) {
		return StringUtils.rightPad(str, length, padCharacter);
	}

	/**
	 * padFront
	 * @param str
	 * @param length
	 * @param padCharacter
	 * @return String
	 */
	public static String padFront(String str, int length, String padCharacter) {
		return StringUtils.leftPad(str, length, padCharacter);
	}

	/**
	 * regionMatches - checks if the substring of s1 matches with the s2
	 * @param ignoreCase
	 * @param s1
	 * @param offset1
	 * @param s2
	 * @param offset2
	 * @param length
	 * @return boolean
	 */
	public static boolean regionMatches(boolean ignoreCase, String s1, int offset1, String s2, int offset2,
			int length) {
		return s1.regionMatches(ignoreCase, offset1, s2, offset2, length);
	}

	/**
	 * replaceAll - replaces all the occurrences of the string with the given value
	 * @param s1
	 * @param regex
	 * @param replacement
	 * @return String
	 */
	public static String replaceAll(String s1, String regex, String replacement) {
		return s1.replaceAll(regex, replacement);
	}

	/**
	 * replaceFirst - replaces the first occurrence of the string with the given value
	 * @param s1
	 * @param regex
	 * @param replacement
	 * @return String
	 */
	public static String replaceFirst(String s1, String regex, String replacement) {
		return s1.replaceFirst(regex, replacement);
	}

	/**
	 * right - gets the right most characters of the given String
	 * @param s1
	 * @param length
	 * @return String
	 */
	public static String right(String s1, int length) {
		return StringUtils.right(s1, length);
	}

	/**
	 * split - splits the string based on the pattern and returns as String[]
	 * @param str
	 * @param regex
	 * @return String[]
	 */
	public static String[] split(String str, String regex) {
		return StringUtils.split(str, regex);
	}

	/**
	 * split2 - splits the string based on the pattern and limit. Returns as String[]
	 * @param str
	 * @param regex
	 * @param limit
	 * @return String[]
	 */
	public static String[] split2(String str, String regex, int limit) {
		return StringUtils.splitPreserveAllTokens(str, regex, limit);
	}

	/**
	 * startsWith - checks if the string starts with the given prefix
	 * @param s1
	 * @param prefix
	 * @return boolean
	 */
	public static boolean startsWith(String s1, String prefix) {
		return StringUtils.startsWith(s1, prefix);
	}

	/**
	 * substring - converts the given object to String and gets the substring of the given index
	 * @param s1
	 * @param beginIndex
	 * @param endIndex
	 * @return String
	 */
	public static String substring(Object s1, int beginIndex, int endIndex) {
		String str = "";
		if (s1 instanceof String) {
			str = (String) s1;
		}
		if (s1 instanceof BigInteger) {
			str = ((BigInteger) s1).intValue() + "";
		}
		if (s1 instanceof Integer) {
			str = ((Integer) s1).intValue() + "";
		}
		return StringUtils.substring(str, getInt(beginIndex), getInt(endIndex));
	}

	/**
	 * substringAfter - gets the substring after the first occurrence of the separator
	 * @param s1
	 * @param s2
	 * @return String
	 */
	public static String substringAfter(String s1, String s2) {
		return StringUtils.substringAfter(s1, s2);
	}

	/**
	 * substringBefore - gets the substring before the first occurrence of the separator 
	 * @param s1
	 * @param s2
	 * @return String
	 */
	public static String substringBefore(String s1, String s2) {
		return StringUtils.substringBefore(s1, s2);
	}

	/**
	 * toLowerCase - converts to lower case
	 * @param s1
	 * @return String
	 */
	public static String toLowerCase(String s1) {
		return StringUtils.lowerCase(s1);
	}

	/**
	 * toUpperCase - converts to upper case
	 * @param s1
	 * @return String
	 */
	public static String toUpperCase(String s1) {
		return StringUtils.upperCase(s1);
	}

	/**
	 * tokenize  - splits based on delimiter and provides an String array
	 * @param str
	 * @param delimiter
	 * @return String[]
	 */
	public static String[] tokenize(String str, String delimiter) {
		return StringUtils.splitPreserveAllTokens(str, delimiter);
	}

	/**
	 * tokenize_allow_empty - splits based on delimiter and provides an String array 
	 * @param str
	 * @param delimiter
	 * @return String[]
	 */
	public static String[] tokenize_allow_empty(String str, String delimiter) {
		return StringUtils.splitPreserveAllTokens(str, delimiter);
	}

	/**
	 * trimPrint - used for debug logging
	 * @param str
	 * @return String
	 */
	public static String trimPrint(String str) {
		log.debug("trimPrint fun--->" + str);
		return StringUtils.trim(str);
	}

	/**
	 * printNode - used for debug logging
	 * @param name
	 * @param node void
	 */
	public static void printNode(String name, Node node) {
		try {
			log.debug(name + ":printnode --->" + getNodeASString(node));
		} catch (TransformerException e) {
			log.error(e.getMessage());
		}
	}

	/**
	 * printObject - used for debug logging
	 * @param name
	 * @param object void
	 */
	public static void printObject(String name, Object object) {
		if (object instanceof SequenceExtent) {
			log.debug(name + ":printNode value-->" + getFirstItemFromSequenceExtend((SequenceExtent) object));
		}
		log.debug("print object --->" + object);
	}

	/**
	 * getFirstItemFromSequenceExtend
	 * @param se
	 * @return String
	 */
	public static String getFirstItemFromSequenceExtend(SequenceExtent se) {
		if (se.getLength() > 0) {
			Item item = se.itemAt(0);
			String value = item.getStringValue();
			return value;
		}
		return null;
	}

	/**
	 * trim
	 * @param str
	 * @return String
	 */
	public static String trim(String str) {
		return StringUtils.trim(str);
	}

	/**
	 * trimObject - used for trimming the given string/string[]/SequenceExtent
	 * @param str
	 * @return String
	 */
	public static String trimObject(Object str) {
		if (str instanceof String) {
			String str1 = (String) str;
			return StringUtils.trim(str1);
		}
		if (str instanceof String[]) {
			String[] str1 = (String[]) str;
			if (str1.length > 0) {
				return StringUtils.trim(str1[0]);
			}
		}
		if (str instanceof SequenceExtent) {
			return StringUtils.trim(getFirstItemFromSequenceExtend((SequenceExtent) str));
		}
		if (str != null) {
			log.debug("tib:trim()--->" + str.getClass() + ":" + str);
		}
		return null;
	}

	/**
	 * valueOfBoolean - used for casting the given boolean to string
	 * @param b
	 * @return String
	 */
	public static String valueOfBoolean(boolean b) {
		return BooleanUtils.toStringTrueFalse(b);
	}

	/**
	 * valueOfDouble - used for casting the given double value to string
	 * @param d
	 * @return String
	 */
	public static String valueOfDouble(double d) {
		return Double.toString(d);
	}

	/**
	 * valueOfInt - used for casting the given int to string
	 * @param i
	 * @return String
	 */
	public static String valueOfInt(int i) {
		return Integer.toString(i);
	}

	/**
	 * valueOfLong - used for casting the given long object to string
	 * @param l
	 * @return String
	 */
	public static String valueOfLong(long l) {
		return Long.toString(l);
	}

	/**
	 * substring_after_last - retrieves substring after last given separator
	 * @param str
	 * @param separator
	 * @return String
	 */
	public static String substring_after_last(String str, String separator) {
		return StringUtils.substringAfterLast(str, separator);
	}

	/**
	 * substring_before_last - retrieves substring before last given separator
	 * @param str
	 * @param separator
	 * @return String
	 */
	public static String substring_before_last(String str, String separator) {
		return StringUtils.substringBeforeLast(str, separator);
	}

	// tibco Date functions.
	/**
	 * after
	 * @param d1
	 * @param d2
	 * @return boolean
	 */
	public static boolean after(DateTime d1, DateTime d2) {
		return d1.isAfter(d2);
	}

	/**
	 * before
	 * @param d1
	 * @param d2
	 * @return boolean
	 */
	public static boolean before(DateTime d1, DateTime d2) {
		return d1.isBefore(d2);
	}

	/**
	 * equals
	 * @param d1
	 * @param d2
	 * @return boolean
	 */
	public static boolean equals(Object d1, Object d2) {
		return d1.equals(d2);
	}

	/**
	 * today
	 * @return DateTime
	 */
	public static DateTime today() {
		return new DateTime();
	}

	/**
	 * timestamp
	 * @return long
	 */
	public static long timestamp() {
		return new Date().getTime();
	}

	/**
	 * get_timezone_from_dateTime - retrieves timezone values from date value
	 * @param date
	 * @return String
	 */
	public static String get_timezone_from_dateTime(String date) {
		if (date.length() != 5) {
			return null;
		}

		TimeZone tz = null;

		Integer offsetHours = Integer.parseInt(date.substring(0, 3));
		Integer offsetMinutes = Integer.parseInt(date.substring(3));

		String[] ids = TimeZone.getAvailableIDs();

		for (int i = 0; i < ids.length; i++) {
			tz = TimeZone.getTimeZone(ids[i]);

			long hours = TimeUnit.MILLISECONDS.toHours(tz.getRawOffset());
			long minutes = Math.abs(TimeUnit.MILLISECONDS.toMinutes(tz.getRawOffset()) % 60);

			if (hours != offsetHours || minutes != offsetMinutes) {
				tz = null;
			} else {
				break;
			}
		}
		return tz.getID();
	}

	/**
	 * format_dateTime - returns date time in the specified date format
	 * @param format
	 * @param dateLong
	 * @return String
	 */
	public static String format_dateTime(String format, long dateLong) {

		SimpleDateFormat simpleDateFormat = new SimpleDateFormat(format);
		String date = simpleDateFormat.format(new Date(dateLong));
		return date.toString();
	}

	/**
	 * render_xml - converts xml node object to string values
	 * @param node
	 * @return
	 * @throws TransformerException String
	 */
	public static String render_xml(Node node) throws TransformerException {
		String str = "";
		try {
			str = getNodeASString(node);
			str = renderStr_xml(str);
		} catch (TransformerException e) {
			log.debug("render_xml input need to verify manually");
			throw e;
		}
		return str;
	}

	/**
	 * renderStr_xml - converts xml to plain string 
	 * @param str
	 * @return
	 * @throws TransformerException String
	 */
	public static String renderStr_xml(String str) throws TransformerException {
		str = str.replaceAll("\\<\\?xml(.+?)\\?\\>", "");
		str = str.trim().replaceAll(">[\\s\r\n]*<", "><");
		str = StringEscapeUtils.escapeXml(str);
		str = str.replaceAll("&amp;", "&");
		return str;
	}

	/**
	 * getNodeASString - converts the node value as String 
	 * @param document
	 * @return String
	 * @throws TransformerException
	 */
	public static String getNodeASString(Node document) throws TransformerException {
		TransformerFactory tf = XMLUtil.getTransformerFactory();
		Transformer t = tf.newTransformer();
		StringWriter sw = new StringWriter();
		t.transform(new DOMSource(document), new StreamResult(sw));
		return sw.toString();
	}

	/**
	 * string_round_fraction - rounding of the double values
	 * @param value
	 * @param fractions
	 * @return String
	 */
	public static String string_round_fraction(String value, int fractions) {
		double scale = Math.pow(10, fractions);
		Float result = (float) (Math.round(Double.parseDouble(value) * scale) / scale);
		return result.toString();
	}

	/**
	 * create_dateTime_timezone  - create date value in the specified format 
	 * @param year
	 * @param month
	 * @param day
	 * @param hours
	 * @param minutes
	 * @param seconds
	 * @param zoneHr
	 * @param zoneMin
	 * @return String
	 */
	public static String create_dateTime_timezone(Object year, Object month, Object day, Object hours, Object minutes,
			Object seconds, Object zoneHr, Object zoneMin) {
		DateTimeZone zone = DateTimeZone.forOffsetHoursMinutes(getInt(zoneHr), getInt(zoneMin));
		DateTime dTime = new DateTime(getInt(year), getInt(month), getInt(day), getInt(hours), getInt(minutes),
				getInt(seconds), zone);
		String datePattern = "yyyy-MM-dd'T'HH:mm:ssZ";
		SimpleDateFormat sdf = new SimpleDateFormat(datePattern);
		// return sdf.format(dTime.toDate());
		return dTime.toString();
	}

	/**
	 * getInt - gets integer values of the incoming param object
	 * @param obj
	 * @return int
	 */
	public static int getInt(Object obj) {
		int intValue = 0;
		if (obj instanceof Integer) {
			intValue = (Integer) obj;
		}
		if (obj instanceof String && StringUtils.isNotBlank((String) obj)) {
			intValue = Integer.parseInt((String) obj);
		}
		if (obj instanceof BigInteger) {
			intValue = ((BigInteger) obj).intValue();
		}
		if (obj instanceof Double) {
			intValue = ((Double) obj).intValue();
		}
		if (obj instanceof DateTimeValue) {
			String dateValue = obj.toString();
			dateValue = dateValue.substring(14, 18);
			intValue = Integer.valueOf(dateValue);
		}
		return intValue;
	}

	/**
	 * get_year_from_dateTime - gets year from date object
	 * @param date
	 * @return String
	 */
	public static String get_year_from_dateTime(Object date) {
		String dateStr = getInt(date) + "";
		if (dateStr.length() > 3) {
			dateStr = dateStr.substring(0, 4);
		}
		return dateStr;
	}

	/**
	 * parse_dateTime - validate date time against the given format
	 * @param format
	 * @param dateStr
	 * @return String
	 */
	public static String parse_dateTime(String format, String dateStr) {
		int dateLength = format.length();
		if (dateStr.length() != dateLength && dateStr.length() > dateLength) {
			dateStr = dateStr.substring(0, dateLength);
		}
		DateTimeFormatter dtf = DateTimeFormat.forPattern(format);
		DateTime dt = dtf.parseDateTime(dateStr);
		return dt.toString();
	}

	/**
	 * validate_dateTime - validate date time against the given format
	 * @param format
	 * @param dateStr
	 * @return boolean
	 */
	public static boolean validate_dateTime(String format, Object dateStr) {
		DateTimeFormatter dtf = DateTimeFormat.forPattern(format);
		try {
			DateTime dt = dtf.parseDateTime((String) dateStr);
			dt.toString();
			return true;
		} catch (Exception e) {
			return false;
		}
	}

	/**
	 * emptyTag - empties a given tag content 
	 * @param xml
	 * @param tag
	 * @return String
	 */
	public static String emptyTag(String xml, String tag) {
		String pattern = "<" + tag + ">[a-zA-Z0-9+-:]*</" + tag + ">";
		String replacement = "<" + tag + "></" + tag + ">";
		return xml.replaceAll(pattern, replacement);
	}

	/**
	 * emptyTag - empties a given tag content
	 * @param xml
	 * @param stag
	 * @param etag
	 * @return String
	 */
	public static String emptyTag(String xml, String stag, String etag) {
		String pattern = "<" + stag + ">[a-zA-Z0-9.+-:]*</" + etag + ">";
		String replacement = "<" + stag + "></" + etag + ">";
		return xml.replaceAll(pattern, replacement);
	}

	/**
	 * removeSpaceAndNewline - used to string formatting - remove space and new line characters
	 * @param xml
	 * @return String
	 */
	public static String removeSpaceAndNewline(String xml) {
		return removeBwTagSpace(xml.trim().replaceAll("[\\t\\n\\r]+", ""));
	}

	/**
	 * removeBwTagSpace - removes BC tags from the xml string
	 * @param xml
	 * @return String
	 */
	public static String removeBwTagSpace(String xml) {
		return xml.replaceAll("(?!>\\s+</) (>\\s+<)", "><");
	}

	/**
	 * create_dateTime - creating date value in the specified format
	 * @param year
	 * @param month
	 * @param day
	 * @param hour
	 * @param min
	 * @param sec
	 * @return String
	 */
	public static String create_dateTime(int year, int month, int day, int hour, int min, int sec) {
		NumberFormat format = new DecimalFormat("00");
		return year + "-" + format.format(month) + "-" + format.format(day) + "T" + format.format(hour) + ":"
				+ format.format(min) + ":" + format.format(sec);
	}

	/**
	 * stringJoin - joins string list using the delimiter
	 * @param delimmiter
	 * @param stringList
	 * @return String
	 */
	public static String stringJoin(Object delimmiter, Object stringList) {
		String convertedString = stringList.toString();
		String[] Initialsplitter = convertedString.split(" ");
		String[] splitter = StringUtils.stripAll(Initialsplitter);
		return String.join(delimmiter.toString(), splitter);
	}

	/**
	 * convertDocumentToString - converts the Document object to String
	 * @param doc
	 * @return String
	 */
	public static String convertDocumentToString(Document doc) {
		TransformerFactory tf = TransformerFactory.newInstance();
		StringWriter writer = new StringWriter();
		try {
			Transformer transformer = tf.newTransformer();
			// transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "yes");
			transformer.transform(new DOMSource(doc), new StreamResult(writer));
			String output = writer.getBuffer().toString();
			return output;
		} catch (TransformerException e) {
			e.printStackTrace();
		}

		return null;
	}

	/**
	 * convertStringToDocument - converts xml string to Document object
	 * @param xmlStr
	 * @return Document
	 */
	public static Document convertStringToDocument(String xmlStr) {
		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
		try {
			DocumentBuilder builder = factory.newDocumentBuilder();
			Document doc = builder.parse(new InputSource(new StringReader(xmlStr)));
			return doc;
		} catch (Exception e) {
			e.printStackTrace();
		}
		return null;
	}
}